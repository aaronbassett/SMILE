# Phase 9 Retrospective: Report Generation

## What Worked Well

- **Builder pattern for complex types**: Using `ReportBuilder` and `GapBuilder` made constructing reports intuitive with fluent API calls, reducing errors from forgotten required fields.
- **Avoiding circular dependencies**: Creating "Input" types in smile-report that mirror orchestrator types (ReportInput, IterationInput, etc.) cleanly avoided circular crate dependencies while keeping strong typing.
- **Parallel module development**: Implementing markdown.rs and json.rs in parallel (separate files, no dependencies between them) allowed fast iteration without blocking.
- **Comprehensive test coverage**: 72 tests for the report crate caught several edge cases early (empty reports, missing locations, truncated output).

## What Didn't Work

- **Single-char string pattern lint**: Clippy's `single_char_pattern` lint flagged `contains("3")` in tests - needed to use `contains('3')` instead. Minor but caught late.
- **Regex dependency addition**: Had to add regex crate mid-phase for line number extraction from step descriptions. Would have been smoother to identify this need upfront during planning.

## Workarounds & Solutions

- **HTML entities for Markdown colors**: Used HTML entities (&#128308;, &#128992;, &#128993;) instead of emoji for consistent rendering across Markdown parsers.
- **Truncation with ellipsis**: `truncate_string` helper handles both single-line and multi-line content by truncating and adding "..." suffix.

## Packages & Dependencies

- **regex**: Added for extracting line numbers from step descriptions using patterns like `line 15`, `L42`, `:42`. Works well with lazy_static for compile-time regex.
- **thiserror**: Already in crate - used for clean error type definition with `#[error("...")]` attributes.

## Patterns & Code

1. **Input/Output type separation**: Instead of depending on another crate for types, define "Input" structs that mirror the data needed. The calling code converts its types to inputs.

2. **Generator pattern**: `*Generator::new(&data).generate()` provides clean API for report generation without state mutation.

3. **Const fn for simple conversions**: Status enum conversions are `const fn` for zero-runtime cost.

4. **Helper functions in modules**: Formatting helpers (`format_duration`, `format_timestamp`, `escape_markdown`) are module-private functions rather than impl methods, keeping the public API clean.

## For Next Time

- Consider adding --format flag to CLI for selecting output format (markdown only, json only, both)
- Gap severity could be auto-detected from patterns in problems (e.g., "error" -> critical, "unclear" -> minor)
- Report generation could be async to match the rest of the CLI
