# Phase 10 Retrospective: End-to-End Integration Testing

## What Worked Well

- **Separate integration test crate**: Creating `tests/integration/` as a workspace member allowed clean separation of integration tests from unit tests while sharing dependencies.
- **Fixture-based testing**: Having `EXPECTED_GAPS.md` alongside the sample tutorial makes test assertions self-documenting and maintainable.
- **Gap builder pattern**: Using `Gap::builder()` makes test code readable and validates that the API is ergonomic.
- **Ignored Docker tests**: Marking Docker-dependent tests with `#[ignore]` allows CI to pass while preserving the test for local/manual runs.

## What Didn't Work

- **Type mismatches**: Initial test code used `Option<T>` where the actual types expected `T`. Had to read the actual type definitions to get the test compiling.
- **Binary crate dependency**: Initially tried to depend on `smile-cli` (a binary crate) from the test crate, which doesn't work - binary crates have no lib target.

## Workarounds & Solutions

- **Fixture path resolution**: Used `CARGO_MANIFEST_DIR` with parent traversal to reliably locate fixtures regardless of working directory.
- **Comprehensive mock data**: Created realistic iteration records that simulate the expected gap detection scenarios.

## Packages & Dependencies

- No new packages needed for integration tests - chrono and tokio from workspace dependencies sufficed.
- The `smile-integration-tests` crate only needs the three core crates (orchestrator, container, report).

## Patterns & Code

1. **Fixture path helper pattern**:
   ```rust
   fn fixture_path() -> PathBuf {
       PathBuf::from(env!("CARGO_MANIFEST_DIR"))
           .parent()
           .and_then(|p| p.parent())
           .map(|p| p.join("tests/integration/fixtures/sample-tutorial"))
           .expect("Failed to find fixture path")
   }
   ```

2. **Intentional gap documentation**: Creating `EXPECTED_GAPS.md` with the fixture documents the test expectations and helps maintain accuracy.

3. **Test isolation with workspace member**: Integration tests as a separate workspace member keeps them isolated while sharing workspace config.

## For Next Time

- Consider adding a mock LLM CLI for true end-to-end testing without API keys
- The Docker test could use a test-specific lightweight image rather than the full smile-base
- Add CI workflow that builds Docker image and runs the ignored test in a Docker-enabled environment
