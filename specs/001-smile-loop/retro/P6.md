# Phase 6 Retrospective: Student Agent + Stuck Detection

**User Stories**: US5 (Student Agent), US6 (Stuck Detection)
**Date Started**: 2026-02-03
**Date Completed**: 2026-02-03

## What Worked Well

1. **Modular Python Architecture**: Breaking the implementation into separate modules (prompts.py, output.py, student.py) made each piece testable and maintainable.

2. **Pydantic for Type Safety**: Using pydantic models for `StudentOutput`, `StudentResultRequest`, `StudentResultResponse` provided automatic validation and clean JSON serialization with alias support for camelCase.

3. **Pattern-based Stuck Detection**: Using regex patterns in `StuckDetector` to classify error types (missing dependency, ambiguous instruction, command failure) provides extensible detection without hardcoding specific error messages.

4. **Helper Method Extraction**: Extracting repetitive logic into helper methods (`_record_failed_attempt`, `_handle_timeout_error`, `_handle_cli_error`) kept the main `run()` method under ruff's complexity limits.

## What Didn't Work

1. **Ruff Complexity Limits**: Initial implementations exceeded ruff's `PLR0911` (too many returns) and `PLR0912` (too many branches) limits. Required refactoring to extract logic into helper methods.

2. **Dictionary-based Match Simplification**: Had to convert pattern-match statements to dictionary lookups to reduce return statement counts (see `should_ask_mentor`).

## Workarounds & Solutions

1. **Walrus Operator for Early Returns**: Using `:=` (walrus operator) patterns like `if fallback := self._record_failed_attempt(...)` reduced code duplication while maintaining readability.

2. **Retry Backoff with Jitter**: Implemented exponential backoff with jitter (`random.uniform(0, delay * 0.25)`) for HTTP retry logic to prevent thundering herd problems.

3. **Multiple JSON Recovery Strategies**: OutputParser implements cascading recovery (direct parse → code block extraction → JSON object search → field extraction) to handle various LLM output formats.

## Packages & Dependencies

- **httpx**: Clean async-capable HTTP client with timeout handling. Better than requests for modern async code.
- **pydantic v2**: `model_validate()`, `model_dump(by_alias=True)`, and `model_json_schema()` are the key methods for JSON handling.

## Patterns & Code

1. **Config-to-Boolean Mapping**: Instead of long match statements, use dictionaries:
   ```python
   condition_map = {
       Condition.A: self.config.field_a,
       Condition.B: self.config.field_b,
       Condition.C: None,  # Always true
   }
   return condition_map.get(condition) is None or condition_map.get(condition)
   ```

2. **Balanced Brace JSON Extraction**: Track brace depth to find valid JSON objects:
   ```python
   depth = 0
   for i, char in enumerate(text):
       if char == '{': depth += 1
       elif char == '}': depth -= 1
       if depth == 0 and start_idx is not None:
           return text[start_idx:i+1]
   ```

3. **Exit Codes for Process Communication**: Use specific exit codes (42 for stop) to communicate wrapper state to orchestrator.

## For Next Time

1. **Consider Protocol-Based Abstraction**: LlmCli could implement a Protocol for easier testing and provider swapping.

2. **Structured Logging**: Replace `print()` to stderr with proper logging framework for production use.

3. **Async-First Design**: OrchestratorClient could benefit from async HTTP calls for better performance in high-concurrency scenarios.
